/*
 * Copyright 2017, The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WIT,OUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//wangshq add
#include   <jni.h>
#include   <stdio.h>    
#include   <stdlib.h>  
#include   <unistd.h>    
#include   <sys/types.h>
#include   <sys/stat.h> 
#include   <fcntl.h>   
#include   <termios.h> 
#include   <errno.h>   
#include   <string.h>
#include   <assert.h>
#include   <strings.h>
#include   "android/log.h"
//#include "pthread.h"

#define JNI_TAG "SubLcd-JNI"
#define SUBLCD_DEVICE_NAME "/dev/sublcd"

#define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO,  JNI_TAG, fmt, ##args)
//#define //LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, JNI_TAG, fmt, ##args)
#define LOGD(fmt, args...)
#define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, JNI_TAG, fmt, ##args)
#define LOGW(fmt, args...) __android_log_print(ANDROID_LOG_WARN,  JNI_TAG, fmt, ##args)
#define LOGF(fmt, args...) __android_log_print(ANDROID_LOG_FATAL, JNI_TAG, fmt, ##args)
//variable define
const unsigned char number16[] = {
	/* 0 */
	0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x10, 0x0F, 0x00,
	/* 1 */
	0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00,
	/* 2 */
	0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30, 0x28, 0x24, 0x22, 0x21, 0x30, 0x00,
	/* 3 */
	0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00,
	/* 4 */
	0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07, 0x04, 0x24, 0x24, 0x3F, 0x24, 0x00,
	/* 5 */
	0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19, 0x21, 0x20, 0x20, 0x11, 0x0E, 0x00,
	/* 6 */
	0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00,
	/* 7 */
	0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,
	/* 8 */
	0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C, 0x22, 0x21, 0x21, 0x22, 0x1C, 0x00,
	/* 9 */
	0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x31, 0x22, 0x22, 0x11, 0x0F, 0x00,
};

const unsigned char number24[] = {
	/* 0 */
	0x00, 0x00, 0x80, 0xC0, 0x60, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x01, 0x07, 0x0E, 0x18, 0x10, 0x10, 0x18, 0x0E, 0x07, 0x01, 0x00,
	/* 1 */
	0x00, 0x00, 0x80, 0x80, 0x80, 0xC0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x10, 0x00, 0x00,
	/* 2 */
	0x00, 0x80, 0x40, 0x20, 0x20, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x80, 0x40,
	0x20, 0x38, 0x1F, 0x07, 0x00, 0x00, 0x00, 0x1C, 0x1A, 0x19, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00,
	/* 3 */
	0x00, 0x80, 0xC0, 0x20, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x10, 0x10,
	0x18, 0x2F, 0xE7, 0x80, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0F, 0x07, 0x00, 0x00,
	/* 4 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xB0, 0x88, 0x86, 0x81,
	0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x1F, 0x1F, 0x10, 0x10, 0x00,
	/* 5 */
	0x00, 0x00, 0xE0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x10, 0x08, 0x08,
	0x08, 0x18, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x07, 0x0B, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x0F, 0x03, 0x00, 0x00,
	/* 6 */
	0x00, 0x00, 0x80, 0xC0, 0x40, 0x20, 0x20, 0x20, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0x21, 0x10, 0x08,
	0x08, 0x08, 0x18, 0xF0, 0xE0, 0x00, 0x00, 0x01, 0x07, 0x0C, 0x18, 0x10, 0x10, 0x10, 0x08, 0x0F, 0x03, 0x00,
	/* 7 */
	0x00, 0x00, 0xC0, 0xE0, 0x60, 0x60, 0x60, 0x60, 0x60, 0xE0, 0x60, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
	0xE0, 0x18, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* 8 */
	0x00, 0x80, 0xC0, 0x60, 0x20, 0x20, 0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x87, 0xEF, 0x2C, 0x18, 0x18,
	0x30, 0x30, 0x68, 0xCF, 0x83, 0x00, 0x00, 0x07, 0x0F, 0x08, 0x10, 0x10, 0x10, 0x10, 0x18, 0x0F, 0x07, 0x00,
	/* 9 */
	0x00, 0x00, 0xC0, 0xC0, 0x20, 0x20, 0x20, 0x20, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x3F, 0x60, 0x40, 0x40,
	0x40, 0x20, 0x10, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x0C, 0x1C, 0x10, 0x10, 0x10, 0x08, 0x0F, 0x03, 0x00, 0x00,
};

const char *JNI_CLASS =	"com/speedata/smallscreenlib/SmallScreenApi";
//pthread_t mythread;

//function define
/*****************************************************************************
	* wangshq 
	* x(0-127), y(0-7) display position
	* content:display text
	* font size (16, 24)
*****************************************************************************/
JNIEXPORT void JNICALL sublcd_write(JNIEnv* env, jobject obj, jint x, jint y, jbyteArray content, jint font)
{
	int i, fd, fixed, offset, size, posx, posy,length;
	FILE *fdgb = NULL;
	jbyte* jbuf;
	unsigned char gbbuffer[80] ={0};
	const unsigned char* pcode;
	const unsigned char* pnumber;
	const unsigned char* buf;

	fd = open(SUBLCD_DEVICE_NAME, O_RDWR);
	LOGI("now open %s\n", SUBLCD_DEVICE_NAME);
	if(fd < 0)
	{
	   LOGI("open sublcd device failed error(%s)\n", strerror(errno));
	   return;
	}
	
	if(font > 0)
	{
		size = 2; i = 0;
		posx = x; posy = y;
		jbuf =(*env)->GetByteArrayElements(env,content, 0);
		length = (*env)->GetArrayLength(env,content);
		buf = (unsigned char*)jbuf;
		LOGI("text length:%d font size:%d\n", length, font);	
		if(font == 16)
		{
			fixed = 32;
			pnumber = number16;
			fdgb = fopen("/system/media/gb2312_16","rb");
		}
		else if(font == 24)
		{
			fixed = 72;
			pnumber = number24;
			fdgb = fopen("/system/media/gb2312_24","rb");
		}
		if(fdgb == NULL)
		{
			LOGI("open gb2312 failed\n");
			return;
		}

		while(length>0)
		{
			gbbuffer[0] = posx;
			gbbuffer[1] = posy;
			if(buf[i]>0xA0)
			{
				offset = (94*(unsigned int)(buf[i]-0xA1)+(buf[i+1]-0xA1))*fixed;
				fseek(fdgb,offset,SEEK_SET);
				fread((gbbuffer+2),1,fixed,fdgb);
				write(fd, gbbuffer, (fixed+2));
				i += 2;
				length -= 2;
				posx += font;
			}
			else
			{
				if(buf[i]>0x2F && buf[i]<0x3A)
				{
					offset = (buf[i]-0x30)*fixed/2;
					memcpy((gbbuffer+2), pnumber+offset, fixed/2);
					write(fd, gbbuffer, (fixed/2+2));
					posx += font/2;
				}
				else if(buf[i]==0x5C && buf[i+1]==0x6E)
				{
					posx = 0;
					posy += font/8;
					i++;
					length--;
				}
				else if(buf[i]==0x20)
				{
					posx += font/2;
				}
				i++;
				length--;
			}
		}
		if(fdgb)
			fclose(fdgb);
		(*env)->ReleaseByteArrayElements(env,content, jbuf, 0);
	}
	else
	{
		gbbuffer[0] = x;
		gbbuffer[1] = y;
		write(fd, gbbuffer, 2);
	}
	close(fd);
}

/*
 * JNI registration.
 */
static JNINativeMethod method_table[] = {
    /* name, signature, funcPtr */
    {"write_sublcd", "(II[BI)V", (void*)sublcd_write},
};

static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *Methods, int numMethods)
{
	jclass clazz;
	clazz = (*env)->FindClass(env, className);
	if(clazz == NULL)
	{
		////LOGE("Can't find jclass: %s", className);
		return JNI_FALSE;
	}
	if((*env)->RegisterNatives(env, clazz, Methods, numMethods) < 0)
	{
		////LOGE("Register real action failed %s", className);
		return JNI_FALSE;
	}
	return JNI_TRUE;
}

static int register_func(JNIEnv *env)
{
	if(!registerNativeMethods(env, JNI_CLASS, method_table, sizeof(method_table) / sizeof(method_table[0])))
	{
		return JNI_FALSE;
	}
	return JNI_TRUE;
}


JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved)
{
	JNIEnv* env = NULL;
	jint result = -1;

	if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_4) != JNI_OK) {
		return -1;
	}
	assert(env != NULL);

	if (!register_func(env)) {//注册
		return -1;
	}
	/* success -- return valid version number */
	result = JNI_VERSION_1_4;

	return result;
}

#if 0
int register_android_server_SublcdService(JNIEnv* env) {
	//pthread_create(&mythread, NULL, mycallback, NULL);
    return jniRegisterNativeMethods(env,
            "com/android/server/SublcdService", method_table, NELEM(method_table));
}
#endif

